/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IStoresClient {
    upsert(upsertCommand: UpsertStoreCommand): Observable<ResultOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class StoresClient implements IStoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    upsert(upsertCommand: UpsertStoreCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Stores/upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(upsertCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }
}

export interface IAuthClient {
    register(registerCommand: RegisterCommand): Observable<ResultOfBoolean>;
    login(loginCommand: LoginCommand): Observable<ResultOfTokenModel>;
    externalLogin(externalLoginCommand: ExternalLoginCommand): Observable<ResultOfTokenModel>;
    confirmEmail(confirmEmailCommand: ConfirmEmailCommand): Observable<ResultOfBoolean>;
    resendLinkConfirmEmail(confirmEmailCommand: ResendConfirmationLinkCommand): Observable<ResultOfBoolean>;
    forgottenPassword(command: ForgottenPasswordCommand): Observable<ResultOfBoolean>;
    resetPassword(command: ResetPasswordCommand): Observable<ResultOfBoolean>;
    refreshToken(command: RefreshTokenCommand): Observable<ResultOfTokenModel>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    register(registerCommand: RegisterCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    login(loginCommand: LoginCommand): Observable<ResultOfTokenModel> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfTokenModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTokenModel>(<any>null);
    }

    externalLogin(externalLoginCommand: ExternalLoginCommand): Observable<ResultOfTokenModel> {
        let url_ = this.baseUrl + "/api/Auth/external-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(externalLoginCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<ResultOfTokenModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTokenModel>(<any>null);
    }

    confirmEmail(confirmEmailCommand: ConfirmEmailCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/confirm-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confirmEmailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    resendLinkConfirmEmail(confirmEmailCommand: ResendConfirmationLinkCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/resend-link-confirm-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confirmEmailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendLinkConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendLinkConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processResendLinkConfirmEmail(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    forgottenPassword(command: ForgottenPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/forgotten-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgottenPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgottenPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processForgottenPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    resetPassword(command: ResetPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    refreshToken(command: RefreshTokenCommand): Observable<ResultOfTokenModel> {
        let url_ = this.baseUrl + "/api/Auth/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResultOfTokenModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTokenModel>(<any>null);
    }
}

export interface IImagesClient {
    uploadImage(imageFile: FileParameter | null | undefined): Observable<ResultOfImageModel>;
}

@Injectable({
    providedIn: 'root'
})
export class ImagesClient implements IImagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    uploadImage(imageFile: FileParameter | null | undefined): Observable<ResultOfImageModel> {
        let url_ = this.baseUrl + "/api/Images/upload-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfImageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfImageModel>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<ResultOfImageModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfImageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfImageModel>(<any>null);
    }
}

export interface ITreeReactionsClient {
    upsert(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReactionTypeModel>;
    upsert2(upsertCommand: UpsertTreeReactionCommand): Observable<ResultOfBoolean>;
    delete(upsertCommand: DeleteTreeReactionCommand): Observable<ResultOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TreeReactionsClient implements ITreeReactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    upsert(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReactionTypeModel> {
        let url_ = this.baseUrl + "/api/TreeReactions/tree-reaction-types?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfICollectionOfTreeReactionTypeModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfICollectionOfTreeReactionTypeModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<ResultOfICollectionOfTreeReactionTypeModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfICollectionOfTreeReactionTypeModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfICollectionOfTreeReactionTypeModel>(<any>null);
    }

    upsert2(upsertCommand: UpsertTreeReactionCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/TreeReactions/upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(upsertCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsert2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert2(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert2(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    delete(upsertCommand: DeleteTreeReactionCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/TreeReactions/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(upsertCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }
}

export interface ITreeReportsClient {
    activeReportsTypes(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReportTypeModel>;
    activeReportsForTypes(treeId: string | null | undefined, reportType: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeReportListModel>;
    archivedReportsTypes(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReportTypeModel>;
    archivedReports(treeId: string | null | undefined, reportType: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeReportListModel>;
    reportTree(message: string | null | undefined, type: string | null | undefined, imageFile: FileParameter | null | undefined, userId: string | null | undefined, treeId: string | null | undefined): Observable<ResultOfBoolean>;
    markReportAsSpam(command: MarkTreeReportAsSpamCommand): Observable<ResultOfBoolean>;
    archiveReport(command: ArchiveTreeReportCommand): Observable<ResultOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TreeReportsClient implements ITreeReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    activeReportsTypes(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReportTypeModel> {
        let url_ = this.baseUrl + "/api/TreeReports/active-reports-types?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveReportsTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveReportsTypes(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfICollectionOfTreeReportTypeModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfICollectionOfTreeReportTypeModel>><any>_observableThrow(response_);
        }));
    }

    protected processActiveReportsTypes(response: HttpResponseBase): Observable<ResultOfICollectionOfTreeReportTypeModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfICollectionOfTreeReportTypeModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfICollectionOfTreeReportTypeModel>(<any>null);
    }

    activeReportsForTypes(treeId: string | null | undefined, reportType: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeReportListModel> {
        let url_ = this.baseUrl + "/api/TreeReports/active-reports?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        if (reportType !== undefined)
            url_ += "ReportType=" + encodeURIComponent("" + reportType) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveReportsForTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveReportsForTypes(<any>response_);
                } catch (e) {
                    return <Observable<TreeReportListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeReportListModel>><any>_observableThrow(response_);
        }));
    }

    protected processActiveReportsForTypes(response: HttpResponseBase): Observable<TreeReportListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeReportListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeReportListModel>(<any>null);
    }

    archivedReportsTypes(treeId: string | null | undefined): Observable<ResultOfICollectionOfTreeReportTypeModel> {
        let url_ = this.baseUrl + "/api/TreeReports/archived-reports-types?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchivedReportsTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchivedReportsTypes(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfICollectionOfTreeReportTypeModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfICollectionOfTreeReportTypeModel>><any>_observableThrow(response_);
        }));
    }

    protected processArchivedReportsTypes(response: HttpResponseBase): Observable<ResultOfICollectionOfTreeReportTypeModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfICollectionOfTreeReportTypeModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfICollectionOfTreeReportTypeModel>(<any>null);
    }

    archivedReports(treeId: string | null | undefined, reportType: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeReportListModel> {
        let url_ = this.baseUrl + "/api/TreeReports/archived-reports?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        if (reportType !== undefined)
            url_ += "ReportType=" + encodeURIComponent("" + reportType) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchivedReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchivedReports(<any>response_);
                } catch (e) {
                    return <Observable<TreeReportListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeReportListModel>><any>_observableThrow(response_);
        }));
    }

    protected processArchivedReports(response: HttpResponseBase): Observable<TreeReportListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeReportListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeReportListModel>(<any>null);
    }

    reportTree(message: string | null | undefined, type: string | null | undefined, imageFile: FileParameter | null | undefined, userId: string | null | undefined, treeId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/TreeReports/report-tree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (message !== null && message !== undefined)
            content_.append("Message", message.toString());
        if (type !== null && type !== undefined)
            content_.append("Type", type.toString());
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");
        if (userId !== null && userId !== undefined)
            content_.append("UserId", userId.toString());
        if (treeId !== null && treeId !== undefined)
            content_.append("TreeId", treeId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportTree(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processReportTree(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    markReportAsSpam(command: MarkTreeReportAsSpamCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/TreeReports/mark-as-spam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkReportAsSpam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkReportAsSpam(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processMarkReportAsSpam(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    archiveReport(command: ArchiveTreeReportCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/TreeReports/archive-report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchiveReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchiveReport(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processArchiveReport(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }
}

export interface ITreesClient {
    getById(id: string | null): Observable<ResultOfTreeModel>;
    getShortInfoById(id: string | null): Observable<ResultOfTreeShortInfoModel>;
    getTrees(page: number | undefined, perPage: number | undefined): Observable<TreeListModel>;
    getTreesShortInfo(page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel>;
    getTreeShortInfo(id: string | null | undefined): Observable<ResultOfTreeShortInfoModel>;
    getTreeDeletedImages(query: GetRandomTreesImagesQuery | null | undefined): Observable<TreeImageListModel>;
    getTreeDeletedImages2(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeImageListModel>;
    getUserTrees(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListModel>;
    getUserTreeShortInfo(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel>;
    getClosestTreesShortInfo(latitude: number | undefined, longitude: number | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel>;
    upsert(id: string | null | undefined, nickname: string | null | undefined, type: string | null | undefined, latitude: number | null | undefined, longitude: number | null | undefined, city: string | null | undefined, category: string | null | undefined, ownerId: string | null | undefined, imageFiles: string[] | null | undefined): Observable<ResultOfString>;
    editTreeImage(id: string | null | undefined, newImageFile: FileParameter | null | undefined): Observable<ResultOfString>;
    addTreeImages(treeId: string | null | undefined, imagesFiles: string[] | null | undefined): Observable<ResultOfListOfString>;
    deleteTreeImages(deleteTreeImagesCommand: DeleteTreeImageCommand): Observable<ResultOfString>;
    restoreTreeImages(restoreTreeImagesCommand: RestoreTreeImageCommand): Observable<ResultOfString>;
}

@Injectable({
    providedIn: 'root'
})
export class TreesClient implements ITreesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: string | null): Observable<ResultOfTreeModel> {
        let url_ = this.baseUrl + "/api/Trees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTreeModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTreeModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfTreeModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTreeModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTreeModel>(<any>null);
    }

    getShortInfoById(id: string | null): Observable<ResultOfTreeShortInfoModel> {
        let url_ = this.baseUrl + "/api/Trees/short-info/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortInfoById(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTreeShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTreeShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortInfoById(response: HttpResponseBase): Observable<ResultOfTreeShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTreeShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTreeShortInfoModel>(<any>null);
    }

    getTrees(page: number | undefined, perPage: number | undefined): Observable<TreeListModel> {
        let url_ = this.baseUrl + "/api/Trees?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrees(<any>response_);
                } catch (e) {
                    return <Observable<TreeListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrees(response: HttpResponseBase): Observable<TreeListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeListModel>(<any>null);
    }

    getTreesShortInfo(page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel> {
        let url_ = this.baseUrl + "/api/Trees/list-short-info?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreesShortInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreesShortInfo(<any>response_);
                } catch (e) {
                    return <Observable<TreeListShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeListShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreesShortInfo(response: HttpResponseBase): Observable<TreeListShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeListShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeListShortInfoModel>(<any>null);
    }

    getTreeShortInfo(id: string | null | undefined): Observable<ResultOfTreeShortInfoModel> {
        let url_ = this.baseUrl + "/api/Trees/short-info?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeShortInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeShortInfo(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfTreeShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfTreeShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreeShortInfo(response: HttpResponseBase): Observable<ResultOfTreeShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfTreeShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfTreeShortInfoModel>(<any>null);
    }

    getTreeDeletedImages(query: GetRandomTreesImagesQuery | null | undefined): Observable<TreeImageListModel> {
        let url_ = this.baseUrl + "/api/Trees/random-images?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeDeletedImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeDeletedImages(<any>response_);
                } catch (e) {
                    return <Observable<TreeImageListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeImageListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreeDeletedImages(response: HttpResponseBase): Observable<TreeImageListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeImageListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeImageListModel>(<any>null);
    }

    getTreeDeletedImages2(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeImageListModel> {
        let url_ = this.baseUrl + "/api/Trees/deleted-images?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeDeletedImages2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeDeletedImages2(<any>response_);
                } catch (e) {
                    return <Observable<TreeImageListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeImageListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreeDeletedImages2(response: HttpResponseBase): Observable<TreeImageListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeImageListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeImageListModel>(<any>null);
    }

    getUserTrees(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListModel> {
        let url_ = this.baseUrl + "/api/Trees/user?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTrees(<any>response_);
                } catch (e) {
                    return <Observable<TreeListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTrees(response: HttpResponseBase): Observable<TreeListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeListModel>(<any>null);
    }

    getUserTreeShortInfo(id: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel> {
        let url_ = this.baseUrl + "/api/Trees/user/short-info?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTreeShortInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTreeShortInfo(<any>response_);
                } catch (e) {
                    return <Observable<TreeListShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeListShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTreeShortInfo(response: HttpResponseBase): Observable<TreeListShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeListShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeListShortInfoModel>(<any>null);
    }

    getClosestTreesShortInfo(latitude: number | undefined, longitude: number | undefined, page: number | undefined, perPage: number | undefined): Observable<TreeListShortInfoModel> {
        let url_ = this.baseUrl + "/api/Trees/closest-trees-short-info?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&"; 
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClosestTreesShortInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClosestTreesShortInfo(<any>response_);
                } catch (e) {
                    return <Observable<TreeListShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeListShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetClosestTreesShortInfo(response: HttpResponseBase): Observable<TreeListShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeListShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeListShortInfoModel>(<any>null);
    }

    upsert(id: string | null | undefined, nickname: string | null | undefined, type: string | null | undefined, latitude: number | null | undefined, longitude: number | null | undefined, city: string | null | undefined, category: string | null | undefined, ownerId: string | null | undefined, imageFiles: string[] | null | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Trees/upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (nickname !== null && nickname !== undefined)
            content_.append("Nickname", nickname.toString());
        if (type !== null && type !== undefined)
            content_.append("Type", type.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (longitude !== null && longitude !== undefined)
            content_.append("Longitude", longitude.toString());
        if (city !== null && city !== undefined)
            content_.append("City", city.toString());
        if (category !== null && category !== undefined)
            content_.append("Category", category.toString());
        if (ownerId !== null && ownerId !== undefined)
            content_.append("OwnerId", ownerId.toString());
        if (imageFiles !== null && imageFiles !== undefined)
            content_.append("ImageFiles", imageFiles.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfString>(<any>null);
    }

    editTreeImage(id: string | null | undefined, newImageFile: FileParameter | null | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Trees/update-tree-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (newImageFile !== null && newImageFile !== undefined)
            content_.append("NewImageFile", newImageFile.data, newImageFile.fileName ? newImageFile.fileName : "NewImageFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTreeImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTreeImage(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processEditTreeImage(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfString>(<any>null);
    }

    addTreeImages(treeId: string | null | undefined, imagesFiles: string[] | null | undefined): Observable<ResultOfListOfString> {
        let url_ = this.baseUrl + "/api/Trees/add-tree-images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (treeId !== null && treeId !== undefined)
            content_.append("TreeId", treeId.toString());
        if (imagesFiles !== null && imagesFiles !== undefined)
            content_.append("ImagesFiles", imagesFiles.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTreeImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTreeImages(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfListOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfListOfString>><any>_observableThrow(response_);
        }));
    }

    protected processAddTreeImages(response: HttpResponseBase): Observable<ResultOfListOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfListOfString>(<any>null);
    }

    deleteTreeImages(deleteTreeImagesCommand: DeleteTreeImageCommand): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Trees/delete-tree-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteTreeImagesCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTreeImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTreeImages(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTreeImages(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfString>(<any>null);
    }

    restoreTreeImages(restoreTreeImagesCommand: RestoreTreeImageCommand): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Trees/restore-tree-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreTreeImagesCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTreeImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTreeImages(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTreeImages(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfString>(<any>null);
    }
}

export interface IUsersClient {
    getById(id: string | null): Observable<ResultOfUserModel>;
    getShortInfoById(id: string | null): Observable<ResultOfUserShortInfoModel>;
    getList(page: number | undefined, perPage: number | undefined): Observable<UserListModel>;
    getAllShortInfo(page: number | undefined, perPage: number | undefined): Observable<UserListShortInfoModel>;
    isUserShortToTree(latitude: number | undefined, longitude: number | undefined, treeId: string | null | undefined): Observable<ResultOfBoolean>;
    edit(command: EditUserCommand): Observable<ResultOfUserModel>;
    changeProfilePicture(id: string | null | undefined, profilePictureFile: FileParameter | null | undefined): Observable<ResultOfString>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: string | null): Observable<ResultOfUserModel> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfUserModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfUserModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfUserModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfUserModel>(<any>null);
    }

    getShortInfoById(id: string | null): Observable<ResultOfUserShortInfoModel> {
        let url_ = this.baseUrl + "/api/Users/short-info/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortInfoById(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfUserShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfUserShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortInfoById(response: HttpResponseBase): Observable<ResultOfUserShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfUserShortInfoModel>(<any>null);
    }

    getList(page: number | undefined, perPage: number | undefined): Observable<UserListModel> {
        let url_ = this.baseUrl + "/api/Users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<UserListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<UserListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListModel>(<any>null);
    }

    getAllShortInfo(page: number | undefined, perPage: number | undefined): Observable<UserListShortInfoModel> {
        let url_ = this.baseUrl + "/api/Users/list-short-info?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShortInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShortInfo(<any>response_);
                } catch (e) {
                    return <Observable<UserListShortInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListShortInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllShortInfo(response: HttpResponseBase): Observable<UserListShortInfoModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListShortInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListShortInfoModel>(<any>null);
    }

    isUserShortToTree(latitude: number | undefined, longitude: number | undefined, treeId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Users/is-user-near-tree?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&"; 
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&"; 
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserShortToTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserShortToTree(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUserShortToTree(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    edit(command: EditUserCommand): Observable<ResultOfUserModel> {
        let url_ = this.baseUrl + "/api/Users/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfUserModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfUserModel>><any>_observableThrow(response_);
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ResultOfUserModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfUserModel>(<any>null);
    }

    changeProfilePicture(id: string | null | undefined, profilePictureFile: FileParameter | null | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Users/change-profile-picture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (profilePictureFile !== null && profilePictureFile !== undefined)
            content_.append("ProfilePictureFile", profilePictureFile.data, profilePictureFile.fileName ? profilePictureFile.fileName : "ProfilePictureFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processChangeProfilePicture(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfString>(<any>null);
    }
}

export interface IWateringsClient {
    getWateringsForTree(treeId: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<WateringListModel>;
    treeWateringsCount(treeId: string | null | undefined): Observable<ResultOfInteger>;
    canUserWaterTree(treeId: string | null | undefined, userId: string | null | undefined): Observable<ResultOfBoolean>;
    waterTree(command: WaterTreeCommand): Observable<ResultOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class WateringsClient implements IWateringsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getWateringsForTree(treeId: string | null | undefined, page: number | undefined, perPage: number | undefined): Observable<WateringListModel> {
        let url_ = this.baseUrl + "/api/Waterings/tree-waterings?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWateringsForTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWateringsForTree(<any>response_);
                } catch (e) {
                    return <Observable<WateringListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<WateringListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWateringsForTree(response: HttpResponseBase): Observable<WateringListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WateringListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WateringListModel>(<any>null);
    }

    treeWateringsCount(treeId: string | null | undefined): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/Waterings/tree-waterings-count?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTreeWateringsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTreeWateringsCount(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processTreeWateringsCount(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfInteger>(<any>null);
    }

    canUserWaterTree(treeId: string | null | undefined, userId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Waterings/can-user-water-tree?";
        if (treeId !== undefined)
            url_ += "TreeId=" + encodeURIComponent("" + treeId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanUserWaterTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanUserWaterTree(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processCanUserWaterTree(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }

    waterTree(command: WaterTreeCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Waterings/water-tree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaterTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaterTree(<any>response_);
                } catch (e) {
                    return <Observable<ResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processWaterTree(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultOfBoolean>(<any>null);
    }
}

export class ResultOfBoolean implements IResultOfBoolean {
    data?: boolean;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfBoolean {
    data?: boolean;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UpsertStoreCommand implements IUpsertStoreCommand {
    id?: string | undefined;
    email!: string;
    password!: string;
    name!: string;
    latitude!: string;
    longitute!: string;
    city!: string;
    workingHours!: string;
    description!: string;
    phoneNumber!: string;

    constructor(data?: IUpsertStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.latitude = _data["latitude"];
            this.longitute = _data["longitute"];
            this.city = _data["city"];
            this.workingHours = _data["workingHours"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpsertStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["latitude"] = this.latitude;
        data["longitute"] = this.longitute;
        data["city"] = this.city;
        data["workingHours"] = this.workingHours;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpsertStoreCommand {
    id?: string | undefined;
    email: string;
    password: string;
    name: string;
    latitude: string;
    longitute: string;
    city: string;
    workingHours: string;
    description: string;
    phoneNumber: string;
}

export class RegisterCommand implements IRegisterCommand {
    email!: string;
    username!: string;
    password!: string;
    city?: string | undefined;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        data["city"] = this.city;
        return data; 
    }
}

export interface IRegisterCommand {
    email: string;
    username: string;
    password: string;
    city?: string | undefined;
}

export class ResultOfTokenModel implements IResultOfTokenModel {
    data?: TokenModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfTokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TokenModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfTokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfTokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfTokenModel {
    data?: TokenModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TokenModel implements ITokenModel {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    expires?: Date;
    id?: string | undefined;
    isStore?: boolean;
    username?: string | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.isStore = _data["isStore"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["isStore"] = this.isStore;
        data["username"] = this.username;
        return data; 
    }
}

export interface ITokenModel {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    expires?: Date;
    id?: string | undefined;
    isStore?: boolean;
    username?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    userId?: string | undefined;
    providerName?: string | undefined;
    providerKey?: string | undefined;
    profilePictureUrl?: string | undefined;

    constructor(data?: IExternalLoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.userId = _data["userId"];
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
            this.profilePictureUrl = _data["profilePictureUrl"];
        }
    }

    static fromJS(data: any): ExternalLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        data["profilePictureUrl"] = this.profilePictureUrl;
        return data; 
    }
}

export interface IExternalLoginCommand {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    userId?: string | undefined;
    providerName?: string | undefined;
    providerKey?: string | undefined;
    profilePictureUrl?: string | undefined;
}

export class ConfirmEmailCommand implements IConfirmEmailCommand {
    token?: string | undefined;
    email?: string | undefined;

    constructor(data?: IConfirmEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ConfirmEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        return data; 
    }
}

export interface IConfirmEmailCommand {
    token?: string | undefined;
    email?: string | undefined;
}

export class ResendConfirmationLinkCommand implements IResendConfirmationLinkCommand {
    email?: string | undefined;

    constructor(data?: IResendConfirmationLinkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationLinkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationLinkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IResendConfirmationLinkCommand {
    email?: string | undefined;
}

export class ForgottenPasswordCommand implements IForgottenPasswordCommand {
    email?: string | undefined;

    constructor(data?: IForgottenPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgottenPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgottenPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IForgottenPasswordCommand {
    email?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        return data; 
    }
}

export interface IResetPasswordCommand {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    accessToken!: string;
    refreshToken!: string;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IRefreshTokenCommand {
    accessToken: string;
    refreshToken: string;
}

export class ResultOfImageModel implements IResultOfImageModel {
    data?: ImageModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ImageModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfImageModel {
    data?: ImageModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class ImageModel implements IImageModel {
    id?: string | undefined;
    url?: string | undefined;

    constructor(data?: IImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        return data; 
    }
}

export interface IImageModel {
    id?: string | undefined;
    url?: string | undefined;
}

export class ResultOfICollectionOfTreeReactionTypeModel implements IResultOfICollectionOfTreeReactionTypeModel {
    data?: TreeReactionTypeModel[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfICollectionOfTreeReactionTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeReactionTypeModel.fromJS(item));
            }
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfICollectionOfTreeReactionTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfICollectionOfTreeReactionTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfICollectionOfTreeReactionTypeModel {
    data?: TreeReactionTypeModel[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeReactionTypeModel implements ITreeReactionTypeModel {
    type?: string | undefined;
    reactionsCount?: number;

    constructor(data?: ITreeReactionTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.reactionsCount = _data["reactionsCount"];
        }
    }

    static fromJS(data: any): TreeReactionTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeReactionTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["reactionsCount"] = this.reactionsCount;
        return data; 
    }
}

export interface ITreeReactionTypeModel {
    type?: string | undefined;
    reactionsCount?: number;
}

export class UpsertTreeReactionCommand implements IUpsertTreeReactionCommand {
    id?: string | undefined;
    userId?: string | undefined;
    treeId?: string | undefined;
    type?: string | undefined;

    constructor(data?: IUpsertTreeReactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.treeId = _data["treeId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UpsertTreeReactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertTreeReactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["treeId"] = this.treeId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUpsertTreeReactionCommand {
    id?: string | undefined;
    userId?: string | undefined;
    treeId?: string | undefined;
    type?: string | undefined;
}

export class DeleteTreeReactionCommand implements IDeleteTreeReactionCommand {
    id?: string | undefined;

    constructor(data?: IDeleteTreeReactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteTreeReactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTreeReactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeleteTreeReactionCommand {
    id?: string | undefined;
}

export class ResultOfICollectionOfTreeReportTypeModel implements IResultOfICollectionOfTreeReportTypeModel {
    data?: TreeReportTypeModel[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfICollectionOfTreeReportTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeReportTypeModel.fromJS(item));
            }
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfICollectionOfTreeReportTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfICollectionOfTreeReportTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfICollectionOfTreeReportTypeModel {
    data?: TreeReportTypeModel[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeReportTypeModel implements ITreeReportTypeModel {
    type?: string | undefined;
    reportsCount?: number;

    constructor(data?: ITreeReportTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.reportsCount = _data["reportsCount"];
        }
    }

    static fromJS(data: any): TreeReportTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeReportTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["reportsCount"] = this.reportsCount;
        return data; 
    }
}

export interface ITreeReportTypeModel {
    type?: string | undefined;
    reportsCount?: number;
}

export class MetaResultOfIListOfTreeReportModelAndPaginationMeta implements IMetaResultOfIListOfTreeReportModelAndPaginationMeta {
    data?: TreeReportModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfTreeReportModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeReportModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfTreeReportModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfTreeReportModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfTreeReportModelAndPaginationMeta {
    data?: TreeReportModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeReportListModel extends MetaResultOfIListOfTreeReportModelAndPaginationMeta implements ITreeReportListModel {

    constructor(data?: ITreeReportListModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TreeReportListModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeReportListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITreeReportListModel extends IMetaResultOfIListOfTreeReportModelAndPaginationMeta {
}

export class TreeReportModel implements ITreeReportModel {
    id?: string | undefined;
    message?: string | undefined;
    imageUrl?: string | undefined;
    type?: TreeReportType;
    treeId?: string | undefined;
    treeNickname?: string | undefined;
    userId?: string | undefined;
    userUserName?: string | undefined;
    userProfilePictureUrl?: string | undefined;

    constructor(data?: ITreeReportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.message = _data["message"];
            this.imageUrl = _data["imageUrl"];
            this.type = _data["type"];
            this.treeId = _data["treeId"];
            this.treeNickname = _data["treeNickname"];
            this.userId = _data["userId"];
            this.userUserName = _data["userUserName"];
            this.userProfilePictureUrl = _data["userProfilePictureUrl"];
        }
    }

    static fromJS(data: any): TreeReportModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeReportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["message"] = this.message;
        data["imageUrl"] = this.imageUrl;
        data["type"] = this.type;
        data["treeId"] = this.treeId;
        data["treeNickname"] = this.treeNickname;
        data["userId"] = this.userId;
        data["userUserName"] = this.userUserName;
        data["userProfilePictureUrl"] = this.userProfilePictureUrl;
        return data; 
    }
}

export interface ITreeReportModel {
    id?: string | undefined;
    message?: string | undefined;
    imageUrl?: string | undefined;
    type?: TreeReportType;
    treeId?: string | undefined;
    treeNickname?: string | undefined;
    userId?: string | undefined;
    userUserName?: string | undefined;
    userProfilePictureUrl?: string | undefined;
}

export enum TreeReportType {
    Broken = 1,
    Dry = 2,
    Damaged = 3,
    Missing = 4,
}

export class PaginationMeta implements IPaginationMeta {
    pagination?: Pagination | undefined;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pagination = _data["pagination"] ? Pagination.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaginationMeta {
    pagination?: Pagination | undefined;
}

export class Pagination implements IPagination {
    totalItems?: number;
    totalPages?: number;
    currentPage?: number;
    perPage?: number;

    constructor(data?: IPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
            this.perPage = _data["perPage"];
        }
    }

    static fromJS(data: any): Pagination {
        data = typeof data === 'object' ? data : {};
        let result = new Pagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        data["perPage"] = this.perPage;
        return data; 
    }
}

export interface IPagination {
    totalItems?: number;
    totalPages?: number;
    currentPage?: number;
    perPage?: number;
}

export class MarkTreeReportAsSpamCommand implements IMarkTreeReportAsSpamCommand {
    treeReportId?: string | undefined;

    constructor(data?: IMarkTreeReportAsSpamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.treeReportId = _data["treeReportId"];
        }
    }

    static fromJS(data: any): MarkTreeReportAsSpamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkTreeReportAsSpamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["treeReportId"] = this.treeReportId;
        return data; 
    }
}

export interface IMarkTreeReportAsSpamCommand {
    treeReportId?: string | undefined;
}

export class ArchiveTreeReportCommand implements IArchiveTreeReportCommand {
    treeId?: string | undefined;
    reportType?: string | undefined;

    constructor(data?: IArchiveTreeReportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.treeId = _data["treeId"];
            this.reportType = _data["reportType"];
        }
    }

    static fromJS(data: any): ArchiveTreeReportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveTreeReportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["treeId"] = this.treeId;
        data["reportType"] = this.reportType;
        return data; 
    }
}

export interface IArchiveTreeReportCommand {
    treeId?: string | undefined;
    reportType?: string | undefined;
}

export class ResultOfTreeModel implements IResultOfTreeModel {
    data?: TreeModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfTreeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TreeModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfTreeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfTreeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfTreeModel {
    data?: TreeModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeModel implements ITreeModel {
    id?: string | undefined;
    nickname?: string | undefined;
    type?: string | undefined;
    plantedOn?: Date;
    latitude?: number;
    longitude?: number;
    status?: TreeStatus;
    city?: string | undefined;
    category?: string | undefined;
    ownerId?: string | undefined;
    owner?: UserModel | undefined;
    images?: ImageModel[] | undefined;

    constructor(data?: ITreeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nickname = _data["nickname"];
            this.type = _data["type"];
            this.plantedOn = _data["plantedOn"] ? new Date(_data["plantedOn"].toString()) : <any>undefined;
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.status = _data["status"];
            this.city = _data["city"];
            this.category = _data["category"];
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? UserModel.fromJS(_data["owner"]) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ImageModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nickname"] = this.nickname;
        data["type"] = this.type;
        data["plantedOn"] = this.plantedOn ? this.plantedOn.toISOString() : <any>undefined;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["status"] = this.status;
        data["city"] = this.city;
        data["category"] = this.category;
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITreeModel {
    id?: string | undefined;
    nickname?: string | undefined;
    type?: string | undefined;
    plantedOn?: Date;
    latitude?: number;
    longitude?: number;
    status?: TreeStatus;
    city?: string | undefined;
    category?: string | undefined;
    ownerId?: string | undefined;
    owner?: UserModel | undefined;
    images?: ImageModel[] | undefined;
}

export enum TreeStatus {
    GoodCondition = 1,
    Damaged = 2,
    Dry = 3,
}

export class UserModel implements IUserModel {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    city?: string | undefined;
    phoneNumber?: string | undefined;
    profilePictureUrl?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.city = _data["city"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureUrl = _data["profilePictureUrl"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["city"] = this.city;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureUrl"] = this.profilePictureUrl;
        return data; 
    }
}

export interface IUserModel {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    city?: string | undefined;
    phoneNumber?: string | undefined;
    profilePictureUrl?: string | undefined;
}

export class ResultOfTreeShortInfoModel implements IResultOfTreeShortInfoModel {
    data?: TreeShortInfoModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfTreeShortInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TreeShortInfoModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfTreeShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfTreeShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfTreeShortInfoModel {
    data?: TreeShortInfoModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeShortInfoModel implements ITreeShortInfoModel {
    id?: string | undefined;
    nickname?: string | undefined;
    plantedOn?: Date;
    status?: TreeStatus;
    city?: string | undefined;
    latitude?: number;
    longitude?: number;
    metresAway?: number;
    owner?: UserShortInfoModel | undefined;
    image?: ImageModel | undefined;

    constructor(data?: ITreeShortInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nickname = _data["nickname"];
            this.plantedOn = _data["plantedOn"] ? new Date(_data["plantedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.city = _data["city"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.metresAway = _data["metresAway"];
            this.owner = _data["owner"] ? UserShortInfoModel.fromJS(_data["owner"]) : <any>undefined;
            this.image = _data["image"] ? ImageModel.fromJS(_data["image"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TreeShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nickname"] = this.nickname;
        data["plantedOn"] = this.plantedOn ? this.plantedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["city"] = this.city;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["metresAway"] = this.metresAway;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITreeShortInfoModel {
    id?: string | undefined;
    nickname?: string | undefined;
    plantedOn?: Date;
    status?: TreeStatus;
    city?: string | undefined;
    latitude?: number;
    longitude?: number;
    metresAway?: number;
    owner?: UserShortInfoModel | undefined;
    image?: ImageModel | undefined;
}

export class UserShortInfoModel implements IUserShortInfoModel {
    id?: string | undefined;
    userName?: string | undefined;
    city?: string | undefined;
    profilePictureUrl?: string | undefined;

    constructor(data?: IUserShortInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.city = _data["city"];
            this.profilePictureUrl = _data["profilePictureUrl"];
        }
    }

    static fromJS(data: any): UserShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["city"] = this.city;
        data["profilePictureUrl"] = this.profilePictureUrl;
        return data; 
    }
}

export interface IUserShortInfoModel {
    id?: string | undefined;
    userName?: string | undefined;
    city?: string | undefined;
    profilePictureUrl?: string | undefined;
}

export class MetaResultOfIListOfTreeModelAndPaginationMeta implements IMetaResultOfIListOfTreeModelAndPaginationMeta {
    data?: TreeModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfTreeModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfTreeModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfTreeModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfTreeModelAndPaginationMeta {
    data?: TreeModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeListModel extends MetaResultOfIListOfTreeModelAndPaginationMeta implements ITreeListModel {

    constructor(data?: ITreeListModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TreeListModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITreeListModel extends IMetaResultOfIListOfTreeModelAndPaginationMeta {
}

export class MetaResultOfIListOfTreeShortInfoModelAndPaginationMeta implements IMetaResultOfIListOfTreeShortInfoModelAndPaginationMeta {
    data?: TreeShortInfoModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfTreeShortInfoModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeShortInfoModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfTreeShortInfoModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfTreeShortInfoModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfTreeShortInfoModelAndPaginationMeta {
    data?: TreeShortInfoModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeListShortInfoModel extends MetaResultOfIListOfTreeShortInfoModelAndPaginationMeta implements ITreeListShortInfoModel {

    constructor(data?: ITreeListShortInfoModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TreeListShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeListShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITreeListShortInfoModel extends IMetaResultOfIListOfTreeShortInfoModelAndPaginationMeta {
}

export class MetaResultOfIListOfTreeImageModelAndPaginationMeta implements IMetaResultOfIListOfTreeImageModelAndPaginationMeta {
    data?: TreeImageModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfTreeImageModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TreeImageModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfTreeImageModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfTreeImageModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfTreeImageModelAndPaginationMeta {
    data?: TreeImageModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class TreeImageListModel extends MetaResultOfIListOfTreeImageModelAndPaginationMeta implements ITreeImageListModel {

    constructor(data?: ITreeImageListModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TreeImageListModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeImageListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITreeImageListModel extends IMetaResultOfIListOfTreeImageModelAndPaginationMeta {
}

export class TreeImageModel implements ITreeImageModel {
    id?: string | undefined;
    url?: string | undefined;
    treeId?: string | undefined;

    constructor(data?: ITreeImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.treeId = _data["treeId"];
        }
    }

    static fromJS(data: any): TreeImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["treeId"] = this.treeId;
        return data; 
    }
}

export interface ITreeImageModel {
    id?: string | undefined;
    url?: string | undefined;
    treeId?: string | undefined;
}

export class GetRandomTreesImagesQuery implements IGetRandomTreesImagesQuery {

    constructor(data?: IGetRandomTreesImagesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetRandomTreesImagesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetRandomTreesImagesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetRandomTreesImagesQuery {
}

export class ResultOfString implements IResultOfString {
    data?: string | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfString {
    data?: string | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class ResultOfListOfString implements IResultOfListOfString {
    data?: string[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfListOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfListOfString {
    data?: string[] | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class DeleteTreeImageCommand implements IDeleteTreeImageCommand {
    imageId!: string;

    constructor(data?: IDeleteTreeImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
        }
    }

    static fromJS(data: any): DeleteTreeImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTreeImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        return data; 
    }
}

export interface IDeleteTreeImageCommand {
    imageId: string;
}

export class RestoreTreeImageCommand implements IRestoreTreeImageCommand {
    imageId!: string;

    constructor(data?: IRestoreTreeImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
        }
    }

    static fromJS(data: any): RestoreTreeImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreTreeImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        return data; 
    }
}

export interface IRestoreTreeImageCommand {
    imageId: string;
}

export class ResultOfUserModel implements IResultOfUserModel {
    data?: UserModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfUserModel {
    data?: UserModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class ResultOfUserShortInfoModel implements IResultOfUserShortInfoModel {
    data?: UserShortInfoModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfUserShortInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserShortInfoModel.fromJS(_data["data"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUserShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfUserShortInfoModel {
    data?: UserShortInfoModel | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class MetaResultOfIListOfUserModelAndPaginationMeta implements IMetaResultOfIListOfUserModelAndPaginationMeta {
    data?: UserModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfUserModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfUserModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfUserModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfUserModelAndPaginationMeta {
    data?: UserModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UserListModel extends MetaResultOfIListOfUserModelAndPaginationMeta implements IUserListModel {

    constructor(data?: IUserListModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UserListModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUserListModel extends IMetaResultOfIListOfUserModelAndPaginationMeta {
}

export class MetaResultOfIListOfUserShortInfoModelAndPaginationMeta implements IMetaResultOfIListOfUserShortInfoModelAndPaginationMeta {
    data?: UserShortInfoModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfUserShortInfoModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserShortInfoModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfUserShortInfoModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfUserShortInfoModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfUserShortInfoModelAndPaginationMeta {
    data?: UserShortInfoModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UserListShortInfoModel extends MetaResultOfIListOfUserShortInfoModelAndPaginationMeta implements IUserListShortInfoModel {

    constructor(data?: IUserListShortInfoModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UserListShortInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserListShortInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUserListShortInfoModel extends IMetaResultOfIListOfUserShortInfoModelAndPaginationMeta {
}

export class EditUserCommand implements IEditUserCommand {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username!: string;
    city!: string;
    phoneNumber?: string | undefined;

    constructor(data?: IEditUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.city = _data["city"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): EditUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["city"] = this.city;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IEditUserCommand {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username: string;
    city: string;
    phoneNumber?: string | undefined;
}

export class MetaResultOfIListOfWateringModelAndPaginationMeta implements IMetaResultOfIListOfWateringModelAndPaginationMeta {
    data?: WateringModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IMetaResultOfIListOfWateringModelAndPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WateringModel.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : <any>undefined;
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MetaResultOfIListOfWateringModelAndPaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new MetaResultOfIListOfWateringModelAndPaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IMetaResultOfIListOfWateringModelAndPaginationMeta {
    data?: WateringModel[] | undefined;
    meta?: PaginationMeta | undefined;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class WateringListModel extends MetaResultOfIListOfWateringModelAndPaginationMeta implements IWateringListModel {

    constructor(data?: IWateringListModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): WateringListModel {
        data = typeof data === 'object' ? data : {};
        let result = new WateringListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IWateringListModel extends IMetaResultOfIListOfWateringModelAndPaginationMeta {
}

export class WateringModel implements IWateringModel {
    id?: string | undefined;
    userUserName?: string | undefined;
    userProfilePictureUrl?: string | undefined;
    wateredOn?: Date;

    constructor(data?: IWateringModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userUserName = _data["userUserName"];
            this.userProfilePictureUrl = _data["userProfilePictureUrl"];
            this.wateredOn = _data["wateredOn"] ? new Date(_data["wateredOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WateringModel {
        data = typeof data === 'object' ? data : {};
        let result = new WateringModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userUserName"] = this.userUserName;
        data["userProfilePictureUrl"] = this.userProfilePictureUrl;
        data["wateredOn"] = this.wateredOn ? this.wateredOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IWateringModel {
    id?: string | undefined;
    userUserName?: string | undefined;
    userProfilePictureUrl?: string | undefined;
    wateredOn?: Date;
}

export class ResultOfInteger implements IResultOfInteger {
    data?: number;
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResultOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResultOfInteger {
    data?: number;
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class WaterTreeCommand implements IWaterTreeCommand {
    treeId?: string | undefined;
    watererId?: string | undefined;

    constructor(data?: IWaterTreeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.treeId = _data["treeId"];
            this.watererId = _data["watererId"];
        }
    }

    static fromJS(data: any): WaterTreeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new WaterTreeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["treeId"] = this.treeId;
        data["watererId"] = this.watererId;
        return data; 
    }
}

export interface IWaterTreeCommand {
    treeId?: string | undefined;
    watererId?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}